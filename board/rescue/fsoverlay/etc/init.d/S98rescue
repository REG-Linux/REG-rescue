#!/bin/bash

# only at start
test "$1" != "start" && exit 0

BOOTCONF="/boot/batocera-boot.conf"
LOG="/boot/rescue.log"
if [ -f "$LOG" ]; then
    mount -o remount,rw /boot   # remounted ro at the end of script
    mv "$LOG" "$LOG".old        # Save previous log
fi
FINISHDIALOG=0      # Avoid displaying 100% dialog for a moment, if never used
SHAREPART=$(batocera-part share_internal)


# UI Output with dialog, default colorset
function dialogoutput()
{
    local percent="$1"
    local text="Do not switch off your device!"

    dialog --backtitle "REG-Linux" --title " Rescue Setup " \
           --mixedgauge "$text" 18 50 "$percent" "${arr[@]}" &>/dev/tty1
}

# Executing parameters and watch background pid
# Changes text messages parsed to dialog --mixedgauge
function textoutput()
{
    local cmd="$3"
    local percent="$2"
    local pid ret
    echo >> "$LOG"    # empty line separator
    echo "cmd:$cmd" >> "$LOG"
    $cmd >> "$LOG" 2>&1 &
    ret=$?
    pid=$!
    arr[$1]=7 #msg: In Progress
    dialogoutput "$percent"
    wait $pid
    code=$?
    echo "cmd code:$code" >> "$LOG"
    arr[$1]=$ret #msg: Depends from return value
}

updateuuid()
{
    find /boot/ -type f \( -iname 'extlinux.conf' -o -iname 'cmdline.txt' -o -iname 'boot.ini' -o -iname 'uEnv.txt' -o -iname 'syslinux.cfg' -o -iname 'grub.cfg' \) -exec sed -i "s/label=REGLINUX/uuid=${NEWUUID}/g;s/uuid=[a-fA-F0-9-]*/uuid=${NEWUUID}/g" {} \+
}

extractupgradefiles()
{
    # Exclude batocera-boot.conf to avoid losing user settings and restoring triggers
    # Also exclude files already updated
    # tar --no-same-owner is needed because fat partition does not support owner attributes
    if ! tar -C /boot/ --no-same-owner --exclude='batocera-boot.conf' --exclude='boot/firmware.update' --exclude='boot/initrd.lz4' --exclude='boot/linux' --exclude='boot/modules.update' --exclude='boot/rescue.update' --zstd -xf "${SHAREMOUNT}/system/upgrade/boot-${board}.tar.zst"
    then
        echo "Error extracting files from ${SHAREMOUNT}/system/upgrade/boot-${board}.tar.zst"
        exit 1
    fi
}

# only when resizing is wanted
if grep -qE '^[ ]*autoresize[ ]*=[ ]*true[ ]*$' "$BOOTCONF"
then
    FINISHDIALOG=1
    # /userdata partition
    PARTNUM=$(batocera-part "share_internal_num")
    mount -o remount,rw /boot   # remounted ro at the end of script
    echo "Partition: $SHAREPART" >> "$LOG"

    # boot disk
    DISK=$(batocera-part prefix "$SHAREPART")
    echo "Disk: $DISK  & Partition number: $PARTNUM">> "$LOG"

    # only for ext4
    PARTTYPE=$(blkid -o value -s TYPE "$SHAREPART")
    echo "Partition type = $PARTTYPE" >> "$LOG"
    if test "$PARTTYPE" = "ext4"
    then
        # Preparing text arrays
        arr=(
        "Aligning GPT table.........." "Pending"
        "Resizing partition.........." "Pending"
        "Informing the Kernel........" "Pending"
        "Expanding SHARE partition..." "Pending"
        "Syncing disk data..........." "Pending"
        )

        # textoutput "Message" "percentage" "command call"
        for i in 1 3 5 7 9; do
        case $i in
          1)
            # partition table
            TABLETYPE=$(blkid -o value -s PTTYPE "$DISK")
            echo "Disk partition table type = $TABLETYPE" >> "$LOG"

            # move backup GPT data structures to the end of the disk
            if [ "$TABLETYPE" = "gpt" ]; then
                echo "Moving 2nd GPT table to the end of the disk" >> "$LOG"
                textoutput $i 10 "sgdisk -e $DISK"
            else
                echo "Skipping GPT table move, disk is not GPT" >> "$LOG"
                textoutput $i 10 ""
            fi
          ;;
          3)
            # resize the partition
            echo "Resizing the partition to 100%" >> "$LOG"
            textoutput $i 30 "parted -s -m -f $DISK resizepart $PARTNUM 100%"
          ;;
          5)
            # update the kernel
            echo "Updating the kernel" >> "$LOG"
            textoutput $i 35 "partprobe $DISK"
          ;;
          7)
            # check & resize the ext4 file system
            echo "Checking ext4 file system" >> "$LOG"
            textoutput $i 40 "e2fsck -f -p $SHAREPART"

            echo "Expanding ext4 the file system" >> "$LOG"
            textoutput $i 50 "resize2fs $SHAREPART"

            echo "Checking the expanded ext4 file system" >> "$LOG"
            textoutput $i 55 "e2fsck -f -p $SHAREPART"
          ;;
          9)
            # finally disk sync
            echo "Final sync" >> "$LOG"
            textoutput $i 60 "sync"
          ;;
        esac
        done
    fi

    # remove the trigger
    sed -i -e s+'^[ ]*autoresize'+'#autoresize'+ "$BOOTCONF"
fi

# format internal share if wanted
FORMAT_INTERNAL_TYPE=$(grep -m 1 -E '^[ ]*format-internal[ ]*=.*$' "$BOOTCONF" | sed -e "s+^[ ]*format-internal[ ]*=[ ]*\(.*\)[ ]*$+\1+")
if [ -n "$FORMAT_INTERNAL_TYPE" ]; then
    FINISHDIALOG=1
    # Preparing text arrays
    arr=("Formatting /userdata........" "Pending")

    mount -o remount,rw /boot   # remounted ro at the end of script
    case "$FORMAT_INTERNAL_TYPE" in
        "btrfs")
            echo "Formatting SHARE partition (btrfs)" >> "$LOG"
            textoutput 1 50 "mkfs.btrfs -L SHARE -f $SHAREPART" # what to do in case of error ? nothing.
        ;;
        "ext4")
            echo "Formatting SHARE partition (ext4)" >> "$LOG"
            textoutput 1 50 "mkfs.ext4 -L SHARE -q -F -F $SHAREPART" # what to do in case of error ? nothing.
        ;;
        "exfat")
            echo "Formatting SHARE partition (exfat)" >> "$LOG"
            textoutput 1 50 "mkfs.exfat -n SHARE $SHAREPART" # what to do in case of error ? nothing.
        ;;
        *)
            # do nothing
            echo "Unsupported format type for SHARE partition ($FORMAT_INTERNAL_TYPE)" >> "$LOG"
    esac

    # remove the trigger
    sed -i -e s+'^[ ]*format-internal'+'#format-internal'+ "$BOOTCONF"
fi

# only when random UUID for boot partition is wanted (usually first boot)
if grep -qE '^[ ]*newbootuuid[ ]*=[ ]*true[ ]*$' "$BOOTCONF"
then
    FINISHDIALOG=1
    # Preparing text arrays
    arr=("Change boot UUID............" "Pending")

    BOOTPART="$(/usr/bin/batocera-part boot)"
    mount -o remount,rw /boot   # remounted ro at the end of script

    echo "Changing UUID of boot partition to a new random UUID" >> "$LOG"
    textoutput 1 90 "fatlabel -i -r $BOOTPART"
    NEWUUID=$(blkid -c /dev/null -o value -s UUID "$BOOTPART")
    echo "New UUID: $NEWUUID" >> "$LOG"

    if [ -n "$NEWUUID" ]
    then
        echo "Updating boot files with new boot partition UUID" >> "$LOG"
        textoutput 1 95 "updateuuid"
    else
        echo "Error getting UUID of boot partition" >> "$LOG"
    fi

    # remove the trigger
    sed -i -e s+'^[ ]*newbootuuid'+'#newbootuuid'+ "$BOOTCONF"
fi

# Search for upgrade file and finish upgrading REG-linux
SHAREMOUNT=$(grep -m 1 -E "^$SHAREPART " /proc/mounts | awk '{print $2}')
if [ -z "$SHAREMOUNT" ]; then
    # Not mounted, do mount
    SHAREMOUNT="/userdata"
    mkdir -p "$SHAREMOUNT"
    PARTTYPE=$(blkid -o value -s TYPE "$SHAREPART")
    if ! batocera-mount "${PARTTYPE}" 1 "$SHAREPART" "$SHAREMOUNT"
    then
        mount -o remount,rw /boot   # remounted ro at the end of script
        echo "Error mounting SHARE partition!" >> "$LOG"
        exit 1
    fi
fi

board=$(cat /boot/boot/batocera.board)
if [ -f "${SHAREMOUNT}/system/upgrade/boot-${board}.tar.zst" ]; then

    FINISHDIALOG=1
    # Preparing text arrays
    arr=("Upgrading REG linux........." "Pending")

    echo "Found update: ${SHAREMOUNT}/system/upgrade/boot-${board}.tar.zst" >> "$LOG"
    mount -o remount,rw /boot || exit 1    # remounted ro at the end of script

    # Free space for the upgrade, delete previous REG-linux OS
    rm -f /boot/boot/reglinux

    textoutput 1 30 "extractupgradefiles"

    # Fix uuid
    BOOTPART=$(/usr/bin/batocera-part boot)
    NEWUUID=$(blkid -o value -s UUID "$BOOTPART")
    if [ -n "$NEWUUID" ]
    then
        echo "Updating boot files with boot partition UUID" >> "$LOG"
        textoutput 1 90 "updateuuid"
    else
        echo "Error getting UUID of boot partition" >> "$LOG"
    fi
fi

# All done
sync
mount -o remount,ro /boot
#Cleanup, restore screen, set progress of last item to 100%
[ "$FINISHDIALOG" -eq 1 ] && dialogoutput 100
clear > /dev/tty1
exit 0
